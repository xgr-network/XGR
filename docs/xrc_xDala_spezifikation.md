### üîÑ Komponenten der xDaLa-Engine

```
üèâ xgr_validateDataTransfer   ‚óÄÔ∏çÔ∏çÔ∏ç Initialer Aufruf
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           ‚îÇ
           ‚ñº
   üè¢ XRC-729        
     (Orchestrierung)  
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
          ‚îÇ (stepId)
          ‚ñº
     üìÑ XRC-137 A    ‚óÄ‚óÄ‚óÄ‚óÄ‚óÄ‚óÄ‚óÄ‚óÄ‚óÄ‚óÄ‚óÄ‚óÄ‚óÄ‚óÄ‚óÄ‚óÄ‚îê
     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê             ‚îÇ
          ‚ñº             ‚îÇ
  [isValid = true/false]    ‚îÇ
          ‚îÇ             ‚îÇ
   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
   ‚îÇ                     ‚îÇ     ‚îÇ
   ‚ñº                     ‚ñº     ‚îÇ
onValid                onInvalid     ‚îÇ
   ‚îÇ                       ‚îÇ      ‚îÇ
   ‚ñº                       ‚îÇ      ‚îÇ
üìÑ XRC-137 B            ‚îÇ      ‚îÇ
                         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò R√ºcksprung
```

Das Validierungssystem basiert auf drei eng verzahnten Komponenten:

- **XRC-137** beschreibt einzelne Validierungsregeln in deklarativer Form (z.‚ÄØB. Preis pr√ºfen, Guthaben abgleichen). Diese Regeln nutzen externe API-Calls und Smart-Contract-Lesefunktionen, um ein valides oder ung√ºltiges Ergebnis zu bestimmen.

- **XRC-729** strukturiert mehrere XRC-137-Instanzen zu komplexen Abl√§ufen. Es definiert, was bei Erfolg oder Misserfolg der einzelnen Validierung passieren soll und in welcher Reihenfolge die Schritte abgearbeitet werden.

- `xgr_validateDataTransfer` ist der zentrale RPC-Endpunkt, der eine XRC-729-Kette sequenziell durchl√§uft. Dabei werden die XRC-137-Regeln nacheinander interpretiert, die jeweiligen Ausg√§nge verarbeitet und gegebenenfalls Ausf√ºhrungsvertr√§ge gestartet ‚Äì solange Gas verf√ºgbar ist oder die Kette nicht abbricht.

---

## üî∑ Komponente: XRC-137 ‚Äì Rules-as-Contract (deklariertes Validierungsmodul)

### üß± Struktur (JSON-basiert ‚Äì inkl. Smart-Contract-Read)

```json
{
  "payload": {
    "Wallet": { "type": "string", "optional": false },
    "ProduktID": { "type": "string", "optional": false }
  },
  "encryptedPayload": {
    "IBAN": { "type": "string", "optional": false }
  },
  "apiCalls": [
    {
      "name": "ProduktPreis",
      "apiUrl": "https://api.shop123.de/preis?produktId=[ProduktID]",
      "default": 0,
      "useDefaultOnError": true,
      "timeoutMs": 3000
    }
  ],
  "contractReads": [
    {
      "name": "WalletBalance",
      "contract": "0xABCDEF0123456789",
      "method": "balanceOf",
      "params": ["[Wallet]"],
      "default": 0,
      "useDefaultOnError": true
    }
  ],
  "rules": [
    { "expression": "[ProduktPreis] > 0" },
    { "expression": "[WalletBalance] >= [ProduktPreis]" }
  ],
  "onValid": {
    "waitMs": 1000,
    "params": {
      "processId": "[prozess_id]",
      "payload": {
        "produktId": "[ProduktID]",
        "preis": "[ProduktPreis]"
      }
    }
  },
  "onInvalid": {
    "waitMs": 1000,
    "params": {
      "processId": "[prozess_id]",
      "payload": {
        "error": "Wallet enth√§lt nicht genug Token oder Produkt ung√ºltig"
      }
    }
  }
}
```

### üîÅ Ablauf:

1. XRC-137 wird **nicht direkt ausgef√ºhrt**, sondern durch die Engine interpretiert.
2. Die Engine (`xgr_validateDataTransfer`) liest:
   - Eingaben aus `payload` (z.‚ÄØB. Wallet, Produkt-ID)
   - verschl√ºsselte Eingaben aus `encryptedPayload` (‚Üí `decryption`, 30.000 Gas)
   - API-Aufrufe (Produktpreis extern)
   - Smart-Contract-Reads (z.‚ÄØB. `balanceOf`)
   - Regeln zur Pr√ºfung
3. Ergebnis ist ein Boolean: `isValid`
4. **Das Verhalten bei G√ºltigkeit oder Ung√ºltigkeit** (`onValid` / `onInvalid`) wird direkt innerhalb der Loop von `xgr_validateDataTransfer` abgehandelt.
5. Auch im Fall von `onInvalid` wird eine Transaktion erzeugt. Diese wird jedoch kontrolliert \*\*mit \*\*\`\` zur√ºckgewiesen, verursacht aber **bewusst Validierungskosten**.

### ‚ö†Ô∏è Entwicklerhinweis:

Wenn bei der Auswertung eines XRC-137 kritische Werte aus einem Smart Contract gelesen und danach im zugeh√∂rigen `executionContract` ver√§ndert werden, muss in `onValid.waitMs` oder `onInvalid.waitMs` mindestens **2000 ms** gewartet werden. Grund: Der n√§chste `contractRead` darf nicht auf einen noch unbest√§tigten Block zugreifen, um Konsistenzfehler zu vermeiden.

---

## üî∑ Komponente: XRC-729 ‚Äì Orchestrierungsstruktur (Knotenpunkte)

### üìå Zweck

Modularisierung und Steuerung einer Abfolge von Validierungsschritten (`XRC-137`) √ºber eindeutige Bezeichner, inkl. Ausf√ºhrung bei Erfolg/Misserfolg.

### üß± Struktur (vereinfachte Repr√§sentation):

```json
[
  {
    "id": "my_orchestration",
    "structure": {
      "step_0_priceCheck": {
        "rule": "0xRULE_ADDRESS_123",
        "executionContract": "0xCONTRACT_EXEC_1",
        "onValidNext": "step_1_store",
        "onInvalidNext": "step_2_notify"
      },
      "step_1_store": {
        "rule": "0xRULE_ADDRESS_456",
        "executionContract": "0xCONTRACT_EXEC_2",
        "onValidNext": null,
        "onInvalidNext": null
      },
      "step_2_notify": {
        "rule": "0xRULE_ADDRESS_789",
        "executionContract": "0xCONTRACT_EXEC_3",
        "onValidNext": null,
        "onInvalidNext": null
      }
    }
  }
]
```

### üìå Hinweise

- Die **erste Rule** wird durch den initialen RPC-Aufruf (mit `stepId`) bestimmt
- Die `rule`-Felder enthalten die **Smart-Contract-Adresse des jeweiligen XRC-137**
- `executionContract` beschreibt den aufzurufenden Contract zur Ausf√ºhrung nach Regelpr√ºfung
- `onValidNext` und `onInvalidNext` referenzieren den n√§chsten Schritt per `stepId`
- Alle Bezeichner (`step_0_x`) sind frei w√§hlbar, aber eindeutig
- Die Engine h√§lt pro Nutzer **eine XRC-729 Instanz**, in der mehrere Orchestrierungen (`id`) verwaltet werden
- Es gibt **keinen festen Startschritt** ‚Äì der Einstiegspunkt ergibt sich **aus dem initialen RPC-Aufruf**, nicht aus einer definierten Startmarkierung
- Die Struktur kann zyklisch sein, wenn gew√ºnscht (z.‚ÄØB. periodisches Triggern bei Feeds)
- Es ist erlaubt, mehrere gleichzeitige Validierungspfade oder rekursive Konstrukte zu modellieren
- **Endlosschleifen sind prinzipiell erlaubt.** Die Validierung endet automatisch, wenn das zugewiesene Gas-Limit aufgebraucht ist.

---

## ‚ú©Ô∏è RPC-Spezifikation: `xgr_validateDataTransfer`

### üìå Zweck

Der zentrale Aufruf zur Verarbeitung einer vollst√§ndigen Validierungskette innerhalb einer XRC-729-Orchestrierung. Alle Schritte werden sequenziell in einer einzigen Ausf√ºhrung durchlaufen.

### üß± Struktur: Eingabeparameter

```json
{
  "orchestration": "0xOrchestrationContract",
  "stepId": "step_0_priceCheck",
  "payload": {
    "IBAN": "DE28243423420012345600"
  },
  "encryption": false,
  "validatorKey": "0x...",
  "recipientKey": "0x...",
  "senderKey": "0x..."
}
```

Alternativ bei verschl√ºsselten Eingaben:

```json
{
  "orchestration": "0xOrchestrationContract",
  "stepId": "step_0_priceCheck",
  "encryptedPayload": "0xABC123...",
  "encryption": true,
  "validatorKey": "0x...",
  "recipientKey": "0x...",
  "senderKey": "0x..."
}
```

‚û°Ô∏è Ergebnis der Entschl√ºsselung wird im Engine-Modul als `inputs.decryption` gespeichert und wie normale Inputs verarbeitet.

### üîÅ Ablauf intern (Loop-basiert)

```ts
let currentStep = input.stepId;
let resultLog = [];
let processId = generateProcessId(...);

while (currentStep) {
  // 1. Hole Regel (XRC-137 Contract)
  // 2. Zerlege Regelstruktur in Teilkomponenten (‚Üí modularer Parser)
  // 3. F√ºhre API-Calls & ContractReads durch
  // 4. Evaluiere Regeln ‚Üí isValid
  // 5. Logge Ergebnis (optional)
  // 6. F√ºhre zugeh√∂rigen executionContract aus (wenn definiert)
  // 7. Warte `waitMs` aus onValid/onInvalid
  // 8. Gehe zu nextStep ‚Üí currentStep = onValidNext / onInvalidNext
}

return {
  processId,
  finalResult,
  executedSteps: resultLog
};
```

### üì§ R√ºckgabe (Beispiel)

```json
{
  "processId": "0xHASH456...",
  "executedSteps": [
    { "step": "step_0_priceCheck", "isValid": true },
    { "step": "step_1_store", "isValid": true }
  ],
  "finalResult": true
}
```

### üìå Hinweise

- Der gesamte Ablauf erfolgt **synchron im selben RPC-Kontext**
- Die Engine verh√§lt sich wie ein **TaskHandler**, der Regelketten vollst√§ndig abarbeitet
- Es existiert **kein festes Limit f√ºr Schleifendurchl√§ufe** ‚Äì Schleifen stoppen automatisch bei Erreichen des Gaslimits oder bei fehlenden nextStep
- Die Inputs bestehen aus Klartext (`payload`) und/oder entschl√ºsseltem Inhalt (`encryptedPayload`) ‚Äì beide werden gleichwertig genutzt
- Die Rule Engine kann auf alle Teilbereiche zugreifen: `payload`, `apiResults`, `contractReads`, `encryptedPayload`
- Bei `encryption: true` erfolgt die Entschl√ºsselung serverseitig vor Auswertung

---

## ‚ú≥Ô∏è Modulare Aufbereitung f√ºr Gasabsch√§tzung und Validierung

Zur einheitlichen Behandlung beider RPCs `xgr_validateDataTransfer` und `xgr_getValidationGas` wird eine zentrale Parsing-Funktion bereitgestellt:

```go
type ParsedXRC137 struct {
  PlainInputs     []InputField
  EncryptedInputs []InputField
  APICalls        []APICall
  ContractReads   []ContractRead
  Expressions     []string
}

func ParseXRC137(rawJSON []byte) (*ParsedXRC137, error)
```

Diese Funktion wird sowohl in der Validierungslogik als auch bei der Gaskalkulation eingesetzt.

Folgefunktionen:

```go
func CalculateGas(parsed *ParsedXRC137) uint64 {
  // z.‚ÄØB. EncryptedInputs ‚Üí +30_000, Regeln/Operators z√§hlen usw.
}
```

Damit ist die gesamte Gassch√§tzung wiederverwendbar und konsistent zur realen Ausf√ºhrung.

